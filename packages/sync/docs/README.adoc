== AeroGear Sync SDK Introduction
The AeroGear Sync SDK can be used to create a GraphQL client which can in turn be used to communicate with your GraphQL backend.

=== Importing the package
[source,js]
----
import {
  createClient,
  strategies
} from '@aerogear/datasync-js';
----

=== Configuration
To provide custom configuration to the client, the following options are available. If you wish, these are also available by using the `DataSyncConfig` interface from the SDK.

[source,js]
----
declare var window: any;

let config: DataSyncConfig = {
  httpUrl: "my-custom-url",
  wsUrl: "my-custom-ws-url"
  dataIdFromObject: "id",
  storage: window.localStorage,
  conflictStrategy: strategies.diffMergeClientWins,
  customLinkBuilder: customLinkBuilder,
  networkStatus: customNetworkStatus,
  mutationsQueueName: "offline-mutations-queue",
  squashing: true
}
----

=== Creating a Client
[source,js]
----
let client = createClient(config);
----


=== Conflict strategies
You can provide your custom conflict resolution strategies to the client in the config by using the provided `ConflictResolutionStrategy` type from the SDK. An example custom strategy is shown below.

[source,js]
----
let clientWins = (serverData, clientData) => {
  return Object.assign(server, client);
};
----

To use this strategy pass this function as conflictStrategy in your config object like so:

[source,js]
----
let config = {
...
  conflictStrategy: clientWins
...
}
----

=== Online Only Queries
To ensure certain queries are not queued and are always delivered to the network layer, you must make use of Graphql directives. To do so define a directive on your schema type definitions like so:

----
directive @onlineOnly on FIELD
----

Next, on your client, ensure the query has the annotation attached like so:

----
exampleQuery(...) @onlineOnly {
  ...
}
----

=== Squashing Queries
By default AeroGear Sync SDK provides squashing of mutations out of the box. This means that if your client is offline and the same mutation is run twice with different parameters they will be squashed into one mutation. This is beneficial as the client will not have to queue a large amount of mutations to replay once it returns online.

This feature is on by default at a global level. To disable it on a global level simply do so in your config:

[source,js]
----
let config = {
...
  squashing: false
...
}
----

To disable this feature at a query level be sure to create a directive on your schema type definitions like so:

----
directive @noSquash on FIELD
----

Next, on your client, ensure the query has the annotation attached like so:

----
exampleQuery(...) @noSquash {
  ...
}
----


