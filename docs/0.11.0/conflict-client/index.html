<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Client Side Conflict Resolution · Offix</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="When performing data synchronization between multiple clients it is common for remote devices to become offline for a certain amount of time. As a result of being offline, data that is modified by a client can become outdated with the server. Further operations on that record can cause a conflict (often called a collision). For more information about offline workflows, please see [Offline Support](/docs/0.11.0/offline-client)"/><meta name="docsearch:version" content="0.11.0"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Client Side Conflict Resolution · Offix"/><meta property="og:type" content="website"/><meta property="og:url" content="https://offix.dev/"/><meta property="og:description" content="When performing data synchronization between multiple clients it is common for remote devices to become offline for a certain amount of time. As a result of being offline, data that is modified by a client can become outdated with the server. Further operations on that record can cause a conflict (often called a collision). For more information about offline workflows, please see [Offline Support](/docs/0.11.0/offline-client)"/><meta property="og:image" content="https://offix.dev/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://offix.dev/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/offix-logo.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/offix-logo.png" alt="Offix"/><h2 class="headerTitleWithLogo">Offix</h2></a><a href="/versions"><h3>0.11.0</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/0.11.0/getting-started" target="_self">Documentation</a></li><li class=""><a href="https://github.com/aerogear/offix" target="_self">Github</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>OffixClient</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.11.0/getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/docs/0.11.0/client-configuration">Client Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">OffixClient</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.11.0/offline-client">Offline Client</a></li><li class="navListItem"><a class="navItem" href="/docs/0.11.0/offix-cache">Client Cache</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/0.11.0/conflict-client">Conflicts Client</a></li><li class="navListItem"><a class="navItem" href="/docs/0.11.0/conflict-server">Conflict Server</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Platforms</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.11.0/react">React</a></li><li class="navListItem"><a class="navItem" href="/docs/0.11.0/react-native">React Native</a></li><li class="navListItem"><a class="navItem" href="/docs/0.11.0/ionic">Ionic and Cordova</a></li><li class="navListItem"><a class="navItem" href="/docs/0.11.0/android">Android</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Advanced topics</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.11.0/offix-scheduler-introduction">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Releases</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/0.11.0/release-notes">Release notes</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Client Side Conflict Resolution</h1></header><article><div><span><p>When performing data synchronization between multiple clients it is common for remote devices to become offline for a certain amount of time. As a result of being offline, data that is modified by a client can become outdated with the server. Further operations on that record can cause a conflict (often called a collision). For more information about offline workflows, please see <a href="/docs/0.11.0/offline-client">Offline Support</a></p>
<p>Offix provides a way to manage and resolve these conflicts for any GraphQL type.
Conflict implementation will require additional elements in your application in order to work:</p>
<ul>
<li>Mutation <code>returnType</code> added on context to any mutation</li>
<li>Additional metadata inside types (for example version field) depending on conflict implementation</li>
</ul>
<p>Conflict mechanism is divided between:</p>
<ul>
<li>Conflict detection
Developers can detect conflicts on resolver level</li>
<li>Conflict resolution
Conflicts are sent back to client and resolved by resending data back to server.</li>
</ul>
<p>Offix allows developers to detect and resolve conflict without user interactions.
By default when no changes were made on the same fields, the implementation will try to resend the modified payload back to the server. When changes on the server and the client cover the same fields one of the specified conflict resolution strategies can be used. The default strategy will apply client changes on top of the server side.
Developers can modify strategies to suit their needs.</p>
<h2><a class="anchor" aria-hidden="true" id="working-with-conflict-resolution-on-client"></a><a href="#working-with-conflict-resolution-on-client" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Working with Conflict Resolution on Client</h2>
<p>To enable conflict resolution we fist need to configure our server side resolvers to perform conflict detection. Detection can rely on many different implementations and return the conflict error back to the client. For more information about how to do this, please see <a href="/docs/0.11.0/conflict-server">Server Side Conflict Resolution</a></p>
<p>The client will then automatically resolve them based on the current strategy and notify listeners if the developer supplied any.</p>
<p>Conflict resolution will work out of the box with the recommended defaults and does not require any specific handling on the client.</p>
<blockquote>
<p>For advanced use cases developers may customize their conflict implementation by supplying a custom <code>conflictProvider</code> in config. See Conflict Resolution Strategies below.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="default-conflict-implementation"></a><a href="#default-conflict-implementation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Default Conflict Implementation</h2>
<p>By default, conflict resolution is configured to rely on a <code>version</code> field on each GraphQL type.
Version field will also need to be saved to the database in order to detect changes on the server</p>
<p>For example:</p>
<pre><code class="hljs css language-javascript">type User {
  <span class="hljs-attr">id</span>: ID!
  version: <span class="hljs-built_in">String</span>!
  name: <span class="hljs-built_in">String</span>!
}
</code></pre>
<p>The version field is controlled on the server and will map the last version that was sent from the server. All operations on the version field happen automatically, however, users need to make sure that the version field is always passed to server for mutations that supports conflict resolution:</p>
<pre><code class="hljs css language-javascript">type Mutation {
  updateUser(id: ID!, <span class="hljs-attr">version</span>: <span class="hljs-built_in">String</span>!): User
}
</code></pre>
<p>Alternatively developers can create input elements that can be reused in every mutation and support conflict resolution.</p>
<pre><code class="hljs css language-javascript">type Mutation {
  updateUser(user: UserInput): User
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="custom-conflict-implementation-by-extening-objectstate"></a><a href="#custom-conflict-implementation-by-extening-objectstate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Conflict implementation by extening ObjectState</h3>
<p>Offix enables flexibility on how conflicts are detected and resolved.
In many cases developers may need different ways of detecting conflits than relying on version field
stored in database. For example if database already have <code>changedAt</code> field that is being supported by trigger it can be used as custom conflict implemementation.</p>
<p>Under the hood conflicts implementations are extending an <code>ObjectState</code> interface.
This interface exist on both client and server and provides functions that help with detection and resolution of conflicts.</p>
<p>The default implementation is <code>VersionedObjectState</code>. This means Offix expects all data which could be conflicted to have a version field. If this is not the case, developers can also provide custom state which Offix will then use for conflict resolution. To do this, Offix expects certain functions to be available under the <code>conflictProvider</code> option in config. These functions and their signatures are:</p>
<p><code>assignServerState(client, server)</code> - assigns the server state to the client state to reduce the chance of a second conflict.</p>
<p><code>hasConlict(client, server)</code> - detects whether or not both sets of data are conflicted.</p>
<p><code>getStateFields()</code> - returns an array of fields that should not be taken into account for conflict purposes.</p>
<p><code>currentState(objectWithState)</code> - returns the current state of the object.</p>
<h2><a class="anchor" aria-hidden="true" id="conflict-resolution-strategies"></a><a href="#conflict-resolution-strategies" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conflict Resolution Strategies</h2>
<p>Offix allows developers to define custom conflict resolution strategies. You can provide custom conflict resolution strategies to the client in the config by using the provided <code>ConflictResolutionStrategies</code> type. By default developers do not need to pass any strategy as <code>UseClient</code> is the default. Custom strategies can be used also to provide different resolution strategy for certain operations:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> customStrategy = {
  resolve = <span class="hljs-function">(<span class="hljs-params">base, server, client, operationName</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> resolvedData;
    <span class="hljs-keyword">switch</span> (operationName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"updateUser"</span>:
        <span class="hljs-keyword">delete</span> client.socialKey
        resolvedData = <span class="hljs-built_in">Object</span>.assign(base, server, client)
        <span class="hljs-keyword">break</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">"updateRole"</span>:
        client.role = <span class="hljs-string">"none"</span>
        resolvedData = <span class="hljs-built_in">Object</span>.assign(base, server, client)
        <span class="hljs-keyword">break</span>
      <span class="hljs-keyword">default</span>:
        resolvedData = <span class="hljs-built_in">Object</span>.assign(base, server, client)
    }
    <span class="hljs-keyword">return</span> resolvedData
  }
}
</code></pre>
<p>This custom strategy provides two custom strategies to be used when a conflict occurs. They are based on the name of the operation to give developers granular control. To use this custom strategy pass it as an argument to conflictStrategy in your config object:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> config = {
...
  conflictStrategy: customStrategy
...
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="listening-to-conflicts"></a><a href="#listening-to-conflicts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Listening to Conflicts</h2>
<p>Offix allows developers to receive information about the data conflict that occurred between the client and the server. The client can be notified in one of two scenarios.</p>
<p>When a conflict occurs Offix will attempt to do a field level resolution of data - meaning it will check all fields of your type to see if both the client or server has changed them.</p>
<p>If both client and server have changed any of the same fields then the <code>conflictOccurred</code> method of your <code>ConflictListener</code> will be triggered.</p>
<p>If the client and server have not changed any of the same fields and the data can be easily merged then the <code>mergeOccurred</code> method of your <code>ConflictListener</code> will be triggered.</p>
<p>Developers can supply their own <code>conflictListener</code> implementation</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">class</span> ConflictLogger <span class="hljs-keyword">implements</span> ConflictListener {
    conflictOccurred(operationName, resolvedData, server, client) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Conflict occurred with the following:"</span>)
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`data: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(resolvedData)}</span>, server: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(server)}</span>, client: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(client)}</span>, operation:  <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(operationName)}</span>`</span>);
    }
    mergeOccurred(operationName, resolvedData, server, client) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Merge occurred with the following:"</span>)
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`data: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(resolvedData)}</span>, server: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(server)}</span>, client: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(client)}</span>, operation:  <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(operationName)}</span>`</span>);
    }
  }
}

<span class="hljs-keyword">let</span> config = {
...
  conflictListener: <span class="hljs-keyword">new</span> ConflictLogger()
...
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/0.11.0/offix-cache"><span class="arrow-prev">← </span><span>Client Cache</span></a><a class="docs-next button" href="/docs/0.11.0/conflict-server"><span>Conflict Server</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#working-with-conflict-resolution-on-client">Working with Conflict Resolution on Client</a></li><li><a href="#default-conflict-implementation">Default Conflict Implementation</a><ul class="toc-headings"><li><a href="#custom-conflict-implementation-by-extening-objectstate">Custom Conflict implementation by extening ObjectState</a></li></ul></li><li><a href="#conflict-resolution-strategies">Conflict Resolution Strategies</a></li><li><a href="#listening-to-conflicts">Listening to Conflicts</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2020 Offix Contributors</section></footer></div></body></html>