window.database = {
  
    
      
    
    "getting-started-html": {
      "title": "Getting Started",
      "category": "",
      "content": "Getting StartedImporting the packageimport {  createClient,  strategies} from 'apollo-offline-client';ConfigurationTo provide custom configuration to the client, the following options are available. If you wish, these are also available by using the DataSyncConfig interface from the SDK.let config: DataSyncConfig = {  httpUrl: \"http://localhost:4000/graphql\",  wsUrl: \"ws://localhost:4000/graphql\",}Creating a Clientlet client = createClient(config);Basic conceptsClient is basing on Apollo GraphQL client that can be used with various web and mobile frameworks.We provide version for web and Apache Cordova.For basic concepts about Apollo GraphQL please refer to documentation for your own platform.For React:https://www.apollographql.com/docs/react/For Angular:https://www.apollographql.com/docs/angular/",
      "url": "/getting-started.html",
      "href": "/getting-started.html"
    }
    ,
  
    
    "": {
      "title": "Overview",
      "category": "",
      "content": "Community extensions to Apollo GraphQL providing:  Offline support:          Creation, Edits and Deletion operations when offline        Request Queue offering scheduling and advanced control over data replication  Listeners for UI  Working seamlessly with OptimisticUI and CacheUpdates  Conflict resolution using different Conflict resolution strategies.  Out of the box Subscriptions and Binary upload that works offline.  Multi platform support. Works with Web, Cordova, Capacitor and React Native.  Framework agnostic (works with React, Angular and Vue)",
      "url": "/",
      "href": "/"
    }
    ,
  
    
    "sections-ref-conflict-client-html": {
      "title": "Client Conflict",
      "category": "",
      "content": "ConflictsWhen obtaining copy of the server side data, client data can get out of the sync.Edits that happened on the client data need to be replicated back to server.When replicating local changes to server it may happen that local changes no longer reflect the server state.This situations are often called “Data Conflicts” or “Data Collisions”Voyager client offers way to detect and handle conflicts for any GraphQL type by supplyingConflictLink implementation to client.When collision is detected it can be handled on both server or client.Working with Conflict ResolutionConflict resolution allows developers to define way to determine how conflicts are detected and handled.Conflict resolution can be fully controlled by server side implementation.If users chose to resolve conflicts in the client they need to configure their resolvers first return conflict back to client. Client will resolve them automatically basing on current strategy and notify listeners if developer supplied any.Conflict resolution will work out of the box with recommended defaults and do not require any specific handling on the client.  For advanced use cases users may customize conflict implementation by supplying custom conflictStateProvider in config.Default conflict implementationBy default plugable conflict resolution is configured to rely on version field on eachGraphQL type.For example:type User {  id: ID!  version: String!  name: String!}Version field is going to be controlled on the server and will map last versionthat was sent from server. All operations on version field happen automaticallyhowever users need to make sure that version field is always being passed to serverfor mutations that supports conflict resolution:type Mutation {  updateUser(id: ID!, version: String!): User}Alternatively developers can create input element that can be reused in every mutationthat supports conflict resolutiontype Mutation {  updateUser(user: UserInput): User}Conflict resolution strategiesClient can define custom resolution strategies.You can provide custom conflict resolution strategies to the client in the config by using the provided ConflictResolutionStrategies type from the SDK. By default developers do not need to pass any strategy (clientVersionWins strategy is used).Custom strategies can be used also to provide different resolution strategy for certain operations:let updateUserConflictResolver = (serverData, clientData) =&gt; {    delete clientData.socialKey    return Object.assign(serverData, clientData);};let updateTaskConflictResolver = (serverData, clientData) =&gt; {    ...};let defaultConflictResolver = (serverData, clientData) =&gt; {  ...};  Note: Client strategies will work only when specific server side resolver explicitly states that conflicts should be fixed on the client. Client strategy will be ignored when conflict is resolved on the server.To use strategy pass it as argument to conflictStrategy in your config object, containing a default to use in the case where you do not provide a strategy for a specific mutations:let config = {...  conflictStrategy: {\"TaskUpdated\": updateTaskConflictResolver, \"UserUpdated\": updateUserConflictResolver, \"default\": defaultConflictResolver}...}Listening to conflictsFramework allows to receive information about the data conflict that occurred between client and server. Client will be notified for both server and client conflicts.Developers can supply their own conflictListener implementationclass ConflictLogger implements ConflictListener {    console.log(`data: ${JSON.stringify(resolvedData)}, server: ${JSON.stringify(server)} client: ${JSON.stringify(client)} `);  }}let config = {...  conflictListener: new ConflictLogger()...}Advanced topicsImplementing Custom Network Status checksTo use your own custom network checks, implement the NetworkStatus interface which provides two functions;  onStatusChangeListener(callback: NetworkStatusChangeCallback): void;  isOffline(): boolean;Logging debug messagesSync package is using debug package to print out debug messagesTo enable debug please execute in consolelocalStorage.debug = 'AeroGearSync:*'Some certain features can be enabled separatelylocalStorage.debug = 'AeroGearSync:OfflineMutations*'Optimistic UIBy default user changes that are made when offline will not appear in the appuntil they going to be synced to server. In some circumstances users may want to see them instantly to perform various operations on the dataWhen performing mutations users can decide to supply optimisticResponse object that willappear instantly in the application UI. SDK provides helper method to work with optimistic responses. import { createOptimisticResponse } from \"@aerogear/datasync-js\"; createOptimisticResponse(\"updateTest\", \"Test\", { data: \"test\" });Users can detect if the provided data is optimistic response by checking optimisticResponse flag is set to true.Listening to the offline queue eventsDevelopers can implement offlineQueueListener that can be passed as config element.This listener is going to be notified about new items that were added to offline queue.Listener can be used to build UI support and show pending changes.This feature can be mixed together with OptimisticResponse to deliver great offline experienceSee example application for more information.",
      "url": "/sections/ref-conflict-client.html",
      "href": "/sections/ref-conflict-client.html"
    }
    ,
  
    
    "sections-ref-conflict-server-html": {
      "title": "Server Conflicts",
      "category": "",
      "content": "Server side conflict resolutionServer side conflict resolution is possible using Node.js package.Usagenpm install apollo-conflicts-serverConflict ResolutionPrerequisites:  GraphQL server with resolvers  Database or any other form of data storage that can cause data conflictsEnabling Conflict ResolutionTo enable conflict resolution developers need to use one of the pluggable conflict resolution strategies in each individual resolver. Depending on the strategy developers will need to provide additional details.Version Based Conflict Resolution  Add conflict package dependency to projectconst { conflictHandler } = require('@aerogear/voyager-conflicts')  Add version field to GraphQL type that should support conflict resolutiontype Greeting {    msg: String    version: Int  }  Add example mutations  type Mutation {    changeGreeting(msg: String!, version: Int!): Greeting  }  Implement resolver for mutationEvery conflict can be handled using a set of predefined steps    // 1. Read data from data source    // 2. Check for conflicts    if (conflictHandler.hasConflict(serverData,clientData)) {      // 3. Resolve conflict (client or server) and return error to client      return await conflictHandler.resolveOnClient(serverData, clientData).response    }    // 4. Call next state to update    greeting = conflictHandler.nextState(clientData)    // 5. Save object to data sourceResolvers can be implemented to handle conflicts on client or server.Depending on  the strategy used, the resolver implementation will differ.Please see the chapter below for individual implementations.Options for Resolving ConflictsConflicts can be resolved on server or client depending on the resolver implementationConflicts on the Client// Dataconst serverState = ...changeGreeting: async (obj, clientState, context, info) =&gt; {    if (conflictHandler.hasConflict(serverState, args)) {      const clientState = args      return await conflictHandler.resolveOnClient(serverState, clientState).response    }    serverState = conflictHandler.nextState(clientState)    return serverState}Conflicts on the Server// Dataconst serverState = ... changeGreeting: async (obj, clientState, context, info) =&gt; {      if (conflictHandler.hasConflict(serverState, clientState)) {        const strategy = customGreetingResolutionStrategy        const { resolvedState, response } = await conflictHandler.resolveOnServer(strategy, serverState, clientState)        serverState = resolvedState        return response      }      serverState = conflictHandler.nextState(clientState)      return serverState    }  Note: For complete implementation see example application located in examples/conflicts folder.Client Conflict implementationSee Voyager Client documentationImplementing Custom Conflict MechanismTheObjectState interface is a complete conflict resolution implementation that provides a set of rules to detect and handle conflict. Interface will allow developers to handle conflict on the client or the server. nextSate method is a way for interface to modify existing object before is being saved to the database.For example when using lastModified field as a way to detect conflicts: public nextState(currentObjectState: ObjectStateData) {    currentObjectState.lastModified = new Date()    return currentObjectState  }",
      "url": "/sections/ref-conflict-server.html",
      "href": "/sections/ref-conflict-server.html"
    }
    ,
  
    
    "sections-ref-offline-html": {
      "title": "Apollo Offline Client",
      "category": "",
      "content": "Offline supportSDK provides first class support for performing GraphQL operations while offline.Queries and mutations are hold in queue that is being configured to hold requests when client goes offline.When client goes offline for long periods of time clients will be able still negotiate local updates with the server state thanks to powerful conflict resolution strategies.Client offers comprehensive set of features to perform data operations when offline.Thanks to offline mutation store users can stage their changes to be replicated backto server when becoming online:Please follow chapters bellow for more information.Querying local cacheBy default client will save all performed query results in the cache.Data will be available to be used when application goes offline.Queries are cached out of the box based on the type and id field.When performing mutations that affects some queries users update method:    client.mutate&lt;Task&gt;({      mutation: ADD_TASK, variables: item,      optimisticResponse: createOptimisticResponse('createTask', 'Task', item),      update: this.updateCacheOnAdd    });Making modifications when offlineAeroGear Sync SDK provides queue that stores mutations performed when offline.By default queue saves data in storage to be available after application restarts.Queue will hold requests until application will come back online.Developers can adjust how queue will process new mutations by supplying custom NetworkStatus implementation.Online Only QueriesTo ensure certain queries are not queued and are always delivered to the network layer, you must make use of Graphql directives.To do so on your client, ensure the query has the annotation attached like so:exampleQuery(...) @onlineOnly {  ...}Listening for EventsIt is possible to provide offlineQueueListener in config to be notified about offline related events:  onOperationEnqueued - Called when new operation is being added to offline queue  onOperationSuccess - Called when back online and operation succeeds  onOperationFailure - Called when back online and operation fails with GraphQL error  queueCleared - Called when offline operation queue is clearedCacheApollo Offline Client is strongly leveraging Apollo Cache.Please follow documentation for more information about caching in Apollo GraphQLhttps://www.apollographql.com/docs/react/advanced/caching.htmlQuerying your dataCache is used to hold data that can be fetched when client is offline.To effectively work with cache users can use cache-first fetchPolicywhen performing queries. This policy will try to use local cache insituations when cache was already populated with the server side data.    return this.apollo.watchQuery&lt;YourType&gt;({      query: YOUR_QUERY,      fetchPolicy: 'cache-first',    });Cache is going to be refueled by subscriptions, pooling or regular queries happening in UI.Designing your typesWhen designing your GraphQL schema types id field will be always required.We also expect that id will be always queried back from server.Library will perform business logic assuming that id field will be supplied and returned from server. Without this field some offline functionalities will not work properly.",
      "url": "/sections/ref-offline.html",
      "href": "/sections/ref-offline.html"
    }
    ,
  
    
    "sections-ref-support-html": {
      "title": "Notes",
      "category": "",
      "content": "SupportFollowing extension is supported by Apollo GraphQL community.We are not affiliated with Apollo team.",
      "url": "/sections/ref-support.html",
      "href": "/sections/ref-support.html"
    }
    ,
  
    
      
    
      
    
      
};
